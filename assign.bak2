      subroutine assign(npoints,zstart,zqso,xs,CDDF,
     +                  nl,ni,nhi4,z4)

      integer npoints,nl,idum,index,i,j,count
      integer s1,s2,s3
      integer index12,index14,index17,index22
      integer,dimension(3) :: ni
      real*8,dimension(3) :: gamma,bins
      real*8,dimension(npoints) :: xs,CDDF
      real*8,dimension(4000) :: nhi4,z4,gamma_int
      real*8 :: c,d,p,q,ran3,dmin
      real*8 :: zstart,zqso,z1p1,z2p1
      real*8 :: nhi,lognhi,z,delta,x
      real*8 :: g_i, g_e
      external ran3
      data bins/12.0,14.0,17.0/
      data gamma/1.51,2.16,1.33/
! -------------------------------------------------------------------
! CALCULATE INDICES for array manipulation
! -------------------------------------------------------------------     
      dmin=0.1
      do i=1,npoints
         d12=abs(xs(i)-12.0)
         if(d12.lt.dmin)then
            dmin=d12
            index12=i
         end if
      end do
! -------------------------------------------------------------------
      dmin=0.1
      do i=1,npoints
         d14=abs(xs(i)-14.0)
         if(d14.lt.dmin)then
            dmin=d14
            index14=i
         end if
      end do
! -------------------------------------------------------------------
      dmin=0.1
      do i=1,npoints
         d17=abs(xs(i)-17.0)
         if(d17.lt.dmin)then
            dmin=d17
            index17=i
         end if
      end do
! -------------------------------------------------------------------
      dmin=0.1
      do i=1,npoints
         d22=abs(xs(i)-22.0)
         if(d22.lt.dmin)then
            dmin=d22
            index22=i
         end if
      end do
! -------------------------------------------------------------------
! CREATE ARRAYS CONTAINING DATA ON NHI AND Z         
! -------------------------------------------------------------------
      z1p1=zstart+1.
      z2p1=zqso+1.
      idum=time()
      index=0; i=0
      s1=0; s2=0; s3=0
      write (6,*) s1,ni(1)
      write (6,*) s2,ni(2)
      write (6,*) s3,ni(3)
      do while (s1.ne.ni(1))
         dmin=1.0
         delta=1.0
 1       c=ran3(idum)
         if (c.lt.1.0) then
! -------------------------------------------------------------------
	    do j=1,npoints
               delta=abs(c-CDDF(j))
               if (delta.lt.dmin) then
                  dmin=delta
                  index=j
               end if
            end do
         else
            goto 1
         end if
         lognhi=xs(index)
! --------------------------------------------------------------------
         if ((lognhi.ge.12.0).and.(lognhi.lt.14.0)) then
            i=i+1
            s1=s1+1
            nhi4(i)=xs(index)
            d=ran3(idum)
            call polint(bins,gamma,3,nhi4(i),g_i,g_e)
            g=g_i
            gp1=g+1.
            p=z2p1**gp1
            q=z1p1**gp1
            x=alog10(real(d*(p-q)+q))
            x=x/gp1
            z=10**x -1.0
            z4(i)=z
            gamma_int(i)=g_i
         end if
      end do
      do while (s2.ne.ni(2))
         dmin=1.0
         delta=1.0
 2       c=ran3(idum)
         if (c.lt.1.0) then
! -------------------------------------------------------------------
	    do j=1,npoints
               delta=abs(c-CDDF(j))
               if (delta.lt.dmin) then
                  dmin=delta
                  index=j
               end if
            end do
         else
            goto 2
         end if
         lognhi=xs(index)
! --------------------------------------------------------------------
         if ((lognhi.ge.14.0).and.(lognhi.lt.17.0)) then
            i=i+1
            s2=s2+1
            nhi4(i)=xs(index)
            d=ran3(idum)
            call polint(bins,gamma,3,nhi4(i),g_i,g_e)
            g=g_i
            gp1=g+1.
            p=z2p1**gp1
            q=z1p1**gp1
            x=alog10(real(d*(p-q)+q))
            x=x/gp1
            z=10**x -1.0
            z4(i)=z
            gamma_int(i)=g_i
         end if
      end do
      do while (s3.ne.ni(3))
         dmin=1.0
         delta=1.0
 3       c=ran3(idum)
         if (c.lt.1.0) then
! -------------------------------------------------------------------
	    do j=1,npoints
               delta=abs(c-CDDF(j))
               if (delta.lt.dmin) then
                  dmin=delta
                  index=j
               end if
            end do
         else
            goto 3
         end if
         lognhi=xs(index)
! --------------------------------------------------------------------
         if ((lognhi.ge.17.0).and.(lognhi.lt.22.0)) then
            i=i+1
            s3=s3+1
            nhi4(i)=xs(index)
            d=ran3(idum)
            call polint(bins,gamma,3,nhi4(i),g_i,g_e)
            write (6,*) 'i,nhi, g_i',i,nhi4(i),g_i
            g=g_i
            gp1=g+1.
            p=z2p1**gp1
            q=z1p1**gp1
            x=alog10(real(d*(p-q)+q))
            x=x/gp1
            z=10**x -1.0
            z4(i)=z
            gamma_int(i)=g_i
         end if
      end do
      do j=1,nl
         write(6,*) j, nhi4(j), z4(j), gamma_int(j)
      end do
      write (6,*) s1,s2,s3,i
      return
      end subroutine assign


      SUBROUTINE polint(xa,ya,n,x,y,dy)
      INTEGER n,NMAX
      REAL*8 dy,x,y,xa(n),ya(n)
      PARAMETER (NMAX=2) 
      INTEGER i,m,ns
      REAL den,dif,dift,ho,hp,w,c(NMAX),d(NMAX)
      ns=1
      dif=abs(x-xa(1))
      do i=1,n
         dift=abs(x-xa(i))
         dift=abs(x-xa(i))
         if (dift.lt.dif) then
            ns=i
            dif=dift
         endif
         c(i)=ya(i) 
         d(i)=ya(i)
      end do 
      y=ya(ns) 
      ns=ns-1
      do m=1,n-1 
         do i=1,n-m 
            ho=xa(i)-x
            hp=xa(i+m)-x
            w=c(i+1)-d(i)
            den=ho-hp
            if(den.eq.0.) stop 'failure in polint'
            den=w/den
            d(i)=hp*den
            c(i)=ho*den
         end do
         if (2*ns.lt.n-m)then
            dy=c(ns+1)
         else
            dy=d(ns)
            ns=ns-1
         endif
         y=y+dy
      end do
      return
      END SUBROUTINE polint


! -------------------------------------------------------------------
      subroutine power_laws(npoints,zstart,zqso,xs,ys,CDDF,
     +                      bigA,gamma,nl,ni)
! -------------------------------------------------------------------
C PURPOSE: prepare constants to be used in calculating the number of 
C          lines and power laws from Kim et al 2013
      implicit none
      integer :: index12,index13p1,index14,index17,index22,index12p75
      integer :: i,j,index,nl,npoints,idum,count
      real*8,dimension(npoints) :: xs,ys,CDDF
      real*8,dimension(3) :: bigA, gamma, n
      integer,dimension(3) :: ni
      real*8 :: dmin,d12,d12p75,d13p1,d14,d17,d22
      real*8 :: int12to14,int13p1to14,int12p75to14
      real*8 :: n1,n2,n3,total
      real*8 :: z1,z1p1,z2,z2p1,zqso, gp1
      real*8 :: zstart,corr,beta, dx
    
! -------------------------------------------------------------------
! CALCULATE INDICES for data manipulation
! -------------------------------------------------------------------     
      dmin=0.1
      do i=1,npoints
         d12=abs(xs(i)-12.0)
         if(d12.lt.dmin)then
            dmin=d12
            index12=i
         end if
      end do
! -------------------------------------------------------------------
      dmin=0.1
      do i=1,npoints
         d12p75=abs(xs(i)-12.75)
         if(d12p75.lt.dmin)then
            dmin=d12p75
            index12p75=i
         end if
      end do
! -------------------------------------------------------------------
      dmin=0.1
      do i=1,npoints
         d13p1=abs(xs(i)-13.1)
         if(d13p1.lt.dmin)then
            dmin=d13p1
            index13p1=i
         end if
      end do
! -------------------------------------------------------------------
      dmin=0.1
      do i=1,npoints
         d14=abs(xs(i)-14.0)
         if(d14.lt.dmin)then
            dmin=d14
            index14=i
         end if
      end do
! -------------------------------------------------------------------
      dmin=0.1
      do i=1,npoints
         d17=abs(xs(i)-17.0)
         if(d17.lt.dmin)then
            dmin=d17
            index17=i
         end if
      end do
! -------------------------------------------------------------------
      dmin=0.1
      do i=1,npoints
         d22=abs(xs(i)-22.0)
         if(d22.lt.dmin)then
            dmin=d22
            index22=i
         end if
      end do
! -------------------------------------------------------------------
! INTEGRATION to account for a gap in data from 12 to 13.1
! -------------------------------------------------------------------
      !numerically integrate spline from 12 to 14 and from 13.1 to 14
      !in steps of dx to get the correction factor 'corr'
      int12to14=0
      int12p75to14=0
      do i=index12,index14
         dx=10**xs(i+1)-10**xs(i)             
         int12to14=int12to14+10**ys(i)*dx
      end do
      do i=index12p75,index14
         dx=10**xs(i+1)-10**xs(i)             
         int12p75to14=int12p75to14+10**ys(i)*dx
      end do
      int13p1to14=0
      do i=index13p1,index14
         dx=10**xs(i+1)-10**xs(i)             
         int13p1to14=int13p1to14+10**ys(i)*dx
      end do
      corr=int12to14/int13p1to14
c      write (6,*) 'int[12.75->14] = ',int12p75to14
c      write (6,*) 'int[13.10->14] = ',int13p1to14
C     corr - correction factor

! -------------------------------------------------------------------
! DETERMINE THE NUMBER OF LINES IN EACH COLUMN DENSITY BIN         
! -------------------------------------------------------------------
      ! dn/dz = A(1+z)^gamma
      ! n = A/(1+gamma)*[(1+z2)^(1+gamma) - (1+z1)^(1+gamma)]
      ! n1(12->14) = corr*A1/(1+gamma1)*[(1+z2)^(1+gamma1) - (1+z1)^(1+gamma1)]
      ! n2(14->17) = A2/(1+gamma2)*[(1+z2)^(1+gamma2) - (1+z1)^(1+gamma2)]
      ! n3(17->22) = A3/(1+gamma3)*[(1+z2)^(1+gamma3) - (1+z1)^(1+gamma3)]
! -------------------------------------------------------------------
      
      z1=zstart
      z1p1=z1+1.
      z2=zqso
      z2p1=zqso+1.
      beta=abs((ys(index14)-ys(index12))/(xs(index14)-xs(index12)))
c      write (6,*) ((10**12.00)/(10**13.1))**(1.-1.46)
      corr=(int12p75to14/int13p1to14)
      write (6,*) 'Numerical correction factor=',corr
      write (6,'(1x,a9,f6.4,3x,a7,f6.4)') 'z_start =',z1,'z_qso =',z2
! -------------------------------------------------------------------
      total=0.0
      do i=1,3
         gp1=gamma(i)+1.
         if(i.eq.1)then
            n(i) = corr*bigA(i)/(gp1)*((z2p1)**(gp1)-(z1p1)**(gp1))
         else
         n(i) = bigA(i)/(gp1)*((z2p1)**(gp1)-(z1p1)**(gp1))
         end if
         total=total+n(i)
      end do   
      ni(1)=nint(n(1))
      ni(2)=nint(n(2))
      ni(3)=nint(n(3))
      nl=ni(1)+ni(2)+ni(3)
c      write (6,*) 'A = corr*bigA/(1+gamma)'
c      write (6,*) 'A (numerical) =',corr*bigA(1)/(gamma(1)+1.)
c      write (6,*) 'gamma = ',gamma(1)
c      write (6,*) 'z1 =',z1
c      write (6,*) 'z2 =',z2
      write (6,*) 'n [12.75->14.00] (predicted) =',nint(n(1))
